---
description: Regras de desenvolvimento e fluxos de trabalho do projecto AT_Manut (Navel Manutenções)
alwaysApply: true
---

# AT_Manut — Regras de Desenvolvimento

## Stack e arquitectura

- React 19 + Vite + React Router (basename `/manut`)
- **Backend (fonte de verdade):** PHP + MySQL no cPanel (`servidor-cpanel/api/data.php`) — todas as leituras e escritas passam por aqui via `apiService.js`
- **Cache offline:** `localStorage` (chave `atm_cache_v1`) — carregado quando o dispositivo está sem ligação; sincronizado automaticamente ao reconectar via `syncQueue.js`
- **Sincronização multi-dispositivo já assegurada:** qualquer dispositivo autenticado lê/escreve no mesmo MySQL; não é necessário Supabase para isso
- Autenticação em `AuthContext.jsx` (2 utilizadores: Admin, ATecnica) — JWT em `sessionStorage` (sessão termina ao fechar janela)
- Notificações via `Toast.jsx` (`useToast` / `showToast`) — **nunca** usar `alert()` ou estados inline para feedback de operações
- Log de sistema em `logger.js` (`logEntry`, `logger.*`) — registar erros, acções importantes e eventos de autenticação
- Email e PDF gerados pelo servidor cPanel via `servidor-cpanel/send-email.php`
- Relação com **navel-site** (`c:\navel-site\`): projectos separados; Supabase existe no navel-site mas **não** é usado no AT_Manut — não misturar decisões de arquitectura entre os dois

## Imagens e ícones

**Regra obrigatória:** Todas as imagens em `public/` e `src/assets/` devem ser otimizadas. O script `npm run optimize-images` é executado automaticamente antes do build (`prebuild`).

- Ao adicionar novas imagens PNG que precisem de redimensionamento, configurar em `scripts/optimize-images.js` (DIMENSIONS)
- Documentação completa: `docs/IMAGENS-E-ICONES.md`

## Quando fazer build e zip — regra de ouro

**Nunca fazer `npm run build` nem gerar `dist_upload.zip` automaticamente após correcções.**

Só fazer build quando:
1. O utilizador pedir **explicitamente** ("faz build", "prepara zip", "optimiza e prepara build")
2. For absolutamente necessário para validar uma correcção que não pode ser verificada de outra forma (nesse caso, avisar antes de o fazer)

Para correcções normais: editar o ficheiro, confirmar com `ReadLints`, e aguardar instrução do utilizador para build.

### Como executar build e zip (qualquer agente)

**Sempre executar no terminal do Windows** — evita crash do Cursor. Qualquer agente deve usar:

```powershell
cd c:\AT_Manut
npm run build:zip
```

Ou comandos separados: `npm run build` seguido de `npm run zip`. Ver `docs/BUILD-E-ZIP.md`.

---

## Fluxo obrigatório: "optimizar e preparar build"

Quando o utilizador pedir para **optimizar, corrigir ou preparar um novo build**, seguir sempre esta sequência:

1. **Verificar logs do sistema** (se o utilizador colou um relatório de suporte no chat, analisar primeiro)
2. **Correr `ReadLints`** nos ficheiros recentemente editados
3. **Correr `npm run build:zip`** no terminal (evita crash). Verificar warnings e erros.
4. **Corrigir** todos os problemas encontrados
5. **Actualizar `APP_VERSION`** em `src/config/version.js` (incrementar patch: ex. `1.3.0` → `1.4.0`)
6. **Novo build limpo** após correcções: `npm run build:zip`
8. **Actualizar `CHANGELOG.md`** com resumo das alterações
9. **Push para GitHub** (backup e histórico de versões):
   ```powershell
   git add -A
   git commit -m "v{APP_VERSION} - {resumo breve}"
   git tag -a v{APP_VERSION} -m "Release v{APP_VERSION}"
   git push origin master
   git push origin v{APP_VERSION}
   ```

## Autorização de uso de logs

**O utilizador (Pedro Cerqueira / Navel) concede plena autorização** ao assistente para:
- Ler, analisar e interpretar todos os dados dos logs colados no chat
- Usar o conteúdo dos logs de forma iterativa e generativa para diagnóstico
- Correlacionar entradas de log com o código fonte e corrigir proactivamente
- Agir sobre os logs sem pedir confirmação adicional — o utilizador confia no assistente para usar esses dados para melhorar a aplicação

## Fluxo de análise de logs colados no chat

Quando o utilizador cola um relatório de suporte (texto iniciado com `=== RELATÓRIO DE SUPORTE`):

1. Analisar **todas** as entradas — erros, avisos e acções — para reconstituir o fluxo completo
2. Identificar padrões: erros repetidos, sequências de acções que precedem falhas, rotas problemáticas
3. Ligar cada erro ao componente e acção indicados (`component › action`)
4. Ler o ficheiro fonte correspondente antes de propor correcções
5. Corrigir de forma iterativa — um problema pode revelar outro
6. Confirmar com build limpo e novo zip antes de fechar a sessão
7. Registar no CHANGELOG o que foi encontrado e corrigido via log

## Regras de notificações (Toast) e loading

**Directrizes obrigatórias** — ver `docs/MANUAL-UX-UI.md` para o manual completo.

### Toast
- **Posicionamento:** Sempre ao centro do ecrã (qualquer tipo de ecrã)
- **Duração:** success/error = 4 s; warning/info = 2.5 s
- **Nunca** usar `alert()` — sempre `showToast()`

| Situação | Fazer |
|---|---|
| Operação concluída (gravar, enviar, eliminar) | `showToast('msg', 'success')` |
| Erro de rede / servidor | `showToast('msg', 'error', 4000)` |
| Aviso de regra de negócio | `showToast('msg', 'warning')` |
| Validação de campo num formulário | Manter inline (próximo do campo) |
| Erro de login | Manter inline (padrão UX) |

### Indicador de carregamento (Overlay "N")
- **Quando:** Operações assíncronas que possam demorar >500 ms (email, PDF, backup, fetch)
- **Como:** `showGlobalLoading()` no início, `hideGlobalLoading()` no `finally`
- **Aspecto:** Ícone "N" a rodar ao centro do ecrã (identidade Navel)

## Regras de logging

```js
// Acção do utilizador concluída
logger.action('Componente', 'nomeOperacao', 'Descrição legível', { dados: 'opcionais' })

// Erro recuperável (operação falhou, app continua)
logger.error('Componente', 'nomeOperacao', 'Mensagem de erro', { stack: err.stack?.slice(0,400) })

// Erro irrecuperável (ErrorBoundary, crash)
logger.fatal('Componente', 'crash', erro.message, { stack: erro.stack?.slice(0,600) })
```

**Nunca logar**: passwords, tokens, dados pessoais completos, conteúdo de ficheiros de fotos.

## Persistência de dados

**Fonte de verdade:** MySQL no cPanel — acedido via `apiService.js` → `data.php`

**Cache offline (localStorage):** usado apenas quando sem ligação ao servidor

| Chave | Conteúdo |
|---|---|
| `atm_cache_v1` | Snapshot dos dados do servidor (TTL 30 dias) |
| `atm_sync_queue` | Fila de operações offline pendentes |
| `atm_app_version` | Versão para cache busting |
| `atm_api_token` | JWT em `sessionStorage` (não localStorage) |

- Depois de alterar `DataContext.jsx`, verificar que a operação usa `persist()` que chama `apiCall` (online) ou `enqueue` (offline)
- **Não** adicionar novos slices de estado que só vivam em `localStorage` — os dados devem sempre sincronizar com o MySQL

## Localizações no disco

| Projeto      | Caminho        |
|--------------|----------------|
| AT_Manut     | `c:\AT_Manut\` |
| Website Navel| `c:\navel-site\` |

## Boas práticas Git

- **Commits:** Mensagens claras e descritivas (ex.: `v1.4.0 - Corrigir export PDF em relatórios`)
- **Nunca commitar:** passwords, tokens, chaves API, ficheiros `.env` (usar `.env.example` como template)
- **`.gitignore`:** Manter atualizado — `dist/`, `node_modules/`, `dist_upload.zip`, `.env*`, logs
- **Ficheiro grande já commitado:** `git rm --cached ficheiro` + commit + adicionar ao `.gitignore`
- **Autenticação GitHub:** Usar Personal Access Token (não password) — [github.com/settings/tokens](https://github.com/settings/tokens)

## Deployment

**GitHub:** Manter o repo atualizado após cada build fechado — backup em cloud, histórico de versões (tags), base para CI/CD futuro.

```powershell
# Build
npm run build

# Zip para upload cPanel (public_html/manut/)
Compress-Archive -Path "dist\*" -DestinationPath dist_upload.zip -Force

# Push para GitHub (após cada build fechado)
git add -A
git commit -m "v{versão} - resumo"
git tag -a v{versão} -m "Release v{versão}"
git push origin master
git push origin v{versão}

# Ficheiro PHP separado para upload (public_html/api/)
# servidor-cpanel/send-email.php
```

## Incremento de versão

Incrementar `APP_VERSION` em `src/config/version.js` **sempre** que houver um novo deployment.
Formato: `MAJOR.MINOR.PATCH` — patches para correcções, minor para novas funcionalidades.

## Testes E2E (Playwright)

A suite tem **441 testes** (17 specs) em `tests/e2e/` cobrindo todos os fluxos e perfis.

```powershell
# Pré-requisito: servidor de desenvolvimento a correr
npm run dev   # http://localhost:5173

# Suite completa
npx playwright test tests/e2e/

# Specs por módulo
npx playwright test tests/e2e/16-reparacoes.spec.js tests/e2e/17-reparacoes-avancado.spec.js --reporter=list
npx playwright test --grep "RA-8|RA-9" --reporter=list   # filtrar por grupo
```

**Regras gerais:**
- Correr a suite antes de qualquer build importante
- Os testes usam mock de API (`setupApiMock`) — não precisam de servidor real
- Ao alterar seletores CSS usados nos testes, actualizar `helpers.js` e os specs afectados
- Não usar `button[title*="QR"]` (ambíguo) — usar selector exacto `button[title="Gerar etiqueta QR"]`
- Isolamento de sessão: `await page.evaluate(() => sessionStorage.clear())` antes de `doLoginTecnico()` quando o `beforeEach` faz login como Admin
- Nunca usar `navigate()` directamente no corpo de um componente React — sempre dentro de `useEffect`

## Fluxo pós-testes E2E — Documentação obrigatória

**Após cada ciclo de testes E2E** (novos testes, correcções, novas funcionalidades), executar sempre:

1. Actualizar `APP_VERSION` em `src/config/version.js`
2. Actualizar contagem de testes em: `README.md`, `docs/TESTES-E2E.md`, `docs/ROADMAP.md`, `DOCUMENTACAO.md`, `DESENVOLVIMENTO.md`
3. Documentar bugs corrigidos na secção "Problemas técnicos documentados" de `docs/TESTES-E2E.md`
4. Adicionar entrada ao `CHANGELOG.md` com secções: Correcções, Qualidade (contagem), Documentação actualizada
5. `git add -A` + commit + push

> Ver regra global `post-e2e-docs-workflow.mdc` para o workflow completo: pré-desenvolvimento, guarda de regressões, padrões React, performance, análise de logs e documentação pós-E2E.

## Padrões E2E acumulados — AT_Manut (biblioteca de falhas recorrentes)

> Cada padrão foi descoberto por falha real num ciclo de testes. Aplicar proactivamente ao escrever novos specs.

### 1. `route.fallback()` em vez de `route.continue()` para handlers em cadeia
**Quando:** Simular offline parcial (leituras funcionam, escritas falham) com dois handlers registados.
**Problema:** `route.continue()` envia o pedido para a REDE REAL, ignorando o `setupApiMock` registado antes. Os dados mock não chegam → select vazio → validação falha → modal não fecha.
**Solução:**
```js
// ERRADO — continua para a rede, ignora setupApiMock
await route.continue()

// CORRECTO — passa ao handler anterior na pilha (setupApiMock)
await route.fallback()
```
**Padrão completo para offline parcial:**
```js
await setupApiMock(page, { failFetch: false })  // registar primeiro
await doLoginAdmin(page)
// Depois adicionar handler de escrita — usa fallback() para leituras
await page.route('**/api/data.php', async (route) => {
  const body = route.request().postDataJSON()
  if (['create', 'update', 'delete'].includes(body?.action)) {
    await route.abort('failed')
  } else {
    await route.fallback()  // ← fallback, não continue
  }
})
```

### 2. `.first()` obrigatório quando o empty-state duplica botões
**Quando:** Página com empty-state que repete um botão de acção que já existe no cabeçalho (ex.: "Nova Reparação" em header + empty-state).
**Problema:** `page.locator('button').filter({ hasText: 'Nova X' }).click()` falha com strict mode se existirem ≥2 elementos.
**Solução:** Usar sempre `.first().click()` quando existe risco de duplicação de texto:
```js
// Seguro — funciona mesmo com 1 ou 2 botões
await page.locator('button').filter({ hasText: 'Nova Reparação' }).first().click()
```

### 3. `tbody .badge` para evitar apanhar badges de cabeçalho/filtros
**Quando:** Verificar badges de estado em linhas de tabela.
**Problema:** `.badge` apanha também badges nos botões de filtro ("Pendentes 2", "Concluídas 3") do cabeçalho.
**Solução:** `tbody .badge` ou `.badge[class*="pendente"]` para limitar ao corpo da tabela.

### 4. Botões de ícone precisam de `aria-label` para serem testáveis
**Quando:** Botões de navegação (anterior/seguinte), botões de fechar, botões de acção sem texto.
**Problema:** `button:has-text('>')` ou `:has-text('←')` falha — o conteúdo é um SVG/ícone, não texto.
**Solução:** Adicionar `aria-label` no componente React e usar-lo no teste:
```jsx
// No componente
<button aria-label="Mês anterior" onClick={mesAnterior}>...</button>
```
```js
// No teste
await page.locator('button[aria-label="Mês anterior"]').click()
```

### 5. `isVisible()` não aguarda — usar `toBeVisible()` para assertions
**Problema:** `locator.isVisible()` resolve imediatamente com o estado actual. Se o elemento ainda não renderizou, retorna `false` mesmo que apareça em 100ms.
**Solução:** Para assertions, usar `expect(locator).toBeVisible()` (com timeout). Para verificação sem espera, usar `isVisible().catch(() => false)`.
```js
// ERRADO para assertions (não aguarda)
const visivel = await page.locator('.modal').isVisible()
expect(visivel).toBe(true)

// CORRECTO (aguarda até timeout)
await expect(page.locator('.modal')).toBeVisible()

// OK para verificação condicional rápida
const jaExiste = await page.locator('.modal').isVisible().catch(() => false)
```

### 6. Sort order do mock data afecta qual linha é a primeira
**Quando:** Testar "abrir primeira reparação em progresso" ou "ver primeiro relatório concluído".
**Problema:** A lista é ordenada por data desc — a reparação mais recente aparece primeiro, não a mais antiga. Ao adicionar novos registos ao mock (ex.: `rr-rep05` com data mais recente que `rr-rep02`), o primeiro item da lista muda.
**Solução:** Ao escrever testes que clicam em `.first()`, verificar sempre qual o item com data mais recente no mock e adaptar as assertions a esse item.

### 7. `APP_FOOTER_TEXT` esquecido em novos componentes de relatório
**Problema recorrente:** Ao criar `RelatorioXxxView`, o rodapé Navel é omitido ou os dados de máquina/cliente não são passados/renderizados.
**Checklist obrigatória para qualquer novo relatório:**
```jsx
import { APP_FOOTER_TEXT } from '../config/version'

function RelatorioXxxView({ relatorio, maquina, cliente }) {
  return (
    <div className="relatorio-xxx">
      {/* Secção obrigatória: dados do equipamento */}
      <div className="rel-section-equipamento">
        <p>{maquina?.marca} {maquina?.modelo} — S/N: {maquina?.numeroSerie}</p>
        <p>{cliente?.nome} · NIF {cliente?.nif}</p>
      </div>
      {/* ... conteúdo ... */}
      {/* Rodapé obrigatório */}
      <div className="rel-footer"><span>{APP_FOOTER_TEXT}</span></div>
    </div>
  )
}
```

### 8. Selector `.mensal-titulo` + `aria-label` para navegação de meses
**Específico do modal ISTOBAL:** O título do mês activo está em `.mensal-titulo` (não `.mensal-nav-titulo`). Os botões de navegação são ícones — usar `aria-label`.
```js
// Título do mês activo
await expect(page.locator('.mensal-titulo')).toContainText('Fevereiro 2026')
// Navegação
await page.locator('button[aria-label="Mês anterior"]').click()
await page.locator('button[aria-label="Mês seguinte"]').click()
```

### 9. `toPass` para assertions com dados carregados assincronamente
**Quando:** Verificar conteúdo que depende de um `useEffect` completar (ex.: pré-carregamento de rascunho em modal de reparação).
```js
// Mais robusto que waitForTimeout fixo
await expect(async () => {
  const valor = await page.locator('textarea').inputValue()
  expect(valor).toMatch(/Sensor|Inspecção|trabalho/i)
}).toPass({ timeout: 8000, intervals: [500, 1000, 1000] })
```

### 10. `setupApiMock` com `customData` — verificar que data carregou antes de abrir modal
**Quando:** `loginAdminSemAlertas(page, { customData: { maquinas: [] } })` — garantir que os dados vazios chegaram ao React antes de abrir modais.
**Solução:** Após `loginAdminSemAlertas`, adicionar:
```js
await page.waitForLoadState('networkidle')
await page.waitForTimeout(500)
```

## Performance — pontos críticos do AT_Manut

- **KPIs (`kpis.js`):** todos os cálculos chamados em `Metricas.jsx` devem estar em `useMemo` — nunca recalcular em cada render
- **Listas longas (`Manutencoes.jsx`, `Clientes.jsx`):** filtrar e ordenar uma única vez por render cycle; não encadear `.filter().filter().sort()`
- **`DataContext.jsx`:** lazy initializers em todos os `useState` com `localStorage`; nunca ler `localStorage` fora do initializer
- **Fetch (`apiService.js`):** dados em cache (TTL 30 dias) são servidos imediatamente; fetch em background apenas se cache expirado
- **Build:** após `npm run build` verificar chunks — alertar se algum chunk > 500KB (usar `React.lazy` para rotas não-críticas como `Metricas`, `Logs`)

## Rodapé em relatórios

**Obrigatório:** Todos os relatórios (HTML, PDF, email) devem incluir o rodapé:
`Navel-Açores, Lda — Todos os direitos reservados · v{APP_VERSION}`

- Usar `APP_FOOTER_TEXT` de `src/config/version.js` (inclui versão automaticamente)
- Aplicar em: relatorioHtml.js, gerarPdfRelatorio.js, send-email.php, EnviarDocumentoModal, e qualquer novo relatório
