---
description: Regras de desenvolvimento e fluxos de trabalho do projecto AT_Manut (Navel Manutenções)
alwaysApply: true
---

# AT_Manut — Regras de Desenvolvimento

## Stack e arquitectura

- React 19 + Vite + React Router (basename `/manut`)
- **Backend (fonte de verdade):** PHP + MySQL no cPanel (`servidor-cpanel/api/data.php`) — todas as leituras e escritas passam por aqui via `apiService.js`
- **Cache offline:** `localStorage` (chave `atm_cache_v1`) — carregado quando o dispositivo está sem ligação; sincronizado automaticamente ao reconectar via `syncQueue.js`
- **Sincronização multi-dispositivo já assegurada:** qualquer dispositivo autenticado lê/escreve no mesmo MySQL; não é necessário Supabase para isso
- Autenticação em `AuthContext.jsx` (2 utilizadores: Admin, ATecnica) — JWT em `sessionStorage` (sessão termina ao fechar janela)
- Notificações via `Toast.jsx` (`useToast` / `showToast`) — **nunca** usar `alert()` ou estados inline para feedback de operações
- Log de sistema em `logger.js` (`logEntry`, `logger.*`) — registar erros, acções importantes e eventos de autenticação
- Email e PDF gerados pelo servidor cPanel via `servidor-cpanel/send-email.php`
- Relação com **navel-site** (`c:\navel-site\`): projectos separados; Supabase existe no navel-site mas **não** é usado no AT_Manut — não misturar decisões de arquitectura entre os dois

## Imagens e ícones

**Regra obrigatória:** Todas as imagens em `public/` e `src/assets/` devem ser otimizadas. O script `npm run optimize-images` é executado automaticamente antes do build (`prebuild`).

- Ao adicionar novas imagens PNG que precisem de redimensionamento, configurar em `scripts/optimize-images.js` (DIMENSIONS)
- Documentação completa: `docs/IMAGENS-E-ICONES.md`

## Fluxo obrigatório: "optimizar e preparar build"

Quando o utilizador pedir para **optimizar, corrigir ou preparar um novo build**, seguir sempre esta sequência:

1. **Verificar logs do sistema** (se o utilizador colou um relatório de suporte no chat, analisar primeiro)
2. **Correr `ReadLints`** nos ficheiros recentemente editados
3. **Correr `npm run build`** e verificar todos os warnings e erros (o prebuild executa optimize-images automaticamente)
4. **Corrigir** todos os problemas encontrados
5. **Actualizar `APP_VERSION`** em `src/config/version.js` (incrementar patch: ex. `1.3.0` → `1.4.0`)
6. **Novo build limpo** após correcções
7. **Gerar zip**: `Compress-Archive -Path "dist\*" -DestinationPath dist_upload.zip -Force`
8. **Actualizar `CHANGELOG.md`** com resumo das alterações
9. **Push para GitHub** (backup e histórico de versões):
   ```powershell
   git add -A
   git commit -m "v{APP_VERSION} - {resumo breve}"
   git tag -a v{APP_VERSION} -m "Release v{APP_VERSION}"
   git push origin master
   git push origin v{APP_VERSION}
   ```

## Autorização de uso de logs

**O utilizador (Pedro Cerqueira / Navel) concede plena autorização** ao assistente para:
- Ler, analisar e interpretar todos os dados dos logs colados no chat
- Usar o conteúdo dos logs de forma iterativa e generativa para diagnóstico
- Correlacionar entradas de log com o código fonte e corrigir proactivamente
- Agir sobre os logs sem pedir confirmação adicional — o utilizador confia no assistente para usar esses dados para melhorar a aplicação

## Fluxo de análise de logs colados no chat

Quando o utilizador cola um relatório de suporte (texto iniciado com `=== RELATÓRIO DE SUPORTE`):

1. Analisar **todas** as entradas — erros, avisos e acções — para reconstituir o fluxo completo
2. Identificar padrões: erros repetidos, sequências de acções que precedem falhas, rotas problemáticas
3. Ligar cada erro ao componente e acção indicados (`component › action`)
4. Ler o ficheiro fonte correspondente antes de propor correcções
5. Corrigir de forma iterativa — um problema pode revelar outro
6. Confirmar com build limpo e novo zip antes de fechar a sessão
7. Registar no CHANGELOG o que foi encontrado e corrigido via log

## Regras de notificações (Toast) e loading

**Directrizes obrigatórias** — ver `docs/MANUAL-UX-UI.md` para o manual completo.

### Toast
- **Posicionamento:** Sempre ao centro do ecrã (qualquer tipo de ecrã)
- **Duração:** success/error = 4 s; warning/info = 2.5 s
- **Nunca** usar `alert()` — sempre `showToast()`

| Situação | Fazer |
|---|---|
| Operação concluída (gravar, enviar, eliminar) | `showToast('msg', 'success')` |
| Erro de rede / servidor | `showToast('msg', 'error', 4000)` |
| Aviso de regra de negócio | `showToast('msg', 'warning')` |
| Validação de campo num formulário | Manter inline (próximo do campo) |
| Erro de login | Manter inline (padrão UX) |

### Indicador de carregamento (Overlay "N")
- **Quando:** Operações assíncronas que possam demorar >500 ms (email, PDF, backup, fetch)
- **Como:** `showGlobalLoading()` no início, `hideGlobalLoading()` no `finally`
- **Aspecto:** Ícone "N" a rodar ao centro do ecrã (identidade Navel)

## Regras de logging

```js
// Acção do utilizador concluída
logger.action('Componente', 'nomeOperacao', 'Descrição legível', { dados: 'opcionais' })

// Erro recuperável (operação falhou, app continua)
logger.error('Componente', 'nomeOperacao', 'Mensagem de erro', { stack: err.stack?.slice(0,400) })

// Erro irrecuperável (ErrorBoundary, crash)
logger.fatal('Componente', 'crash', erro.message, { stack: erro.stack?.slice(0,600) })
```

**Nunca logar**: passwords, tokens, dados pessoais completos, conteúdo de ficheiros de fotos.

## Persistência de dados

**Fonte de verdade:** MySQL no cPanel — acedido via `apiService.js` → `data.php`

**Cache offline (localStorage):** usado apenas quando sem ligação ao servidor

| Chave | Conteúdo |
|---|---|
| `atm_cache_v1` | Snapshot dos dados do servidor (TTL 30 dias) |
| `atm_sync_queue` | Fila de operações offline pendentes |
| `atm_app_version` | Versão para cache busting |
| `atm_api_token` | JWT em `sessionStorage` (não localStorage) |

- Depois de alterar `DataContext.jsx`, verificar que a operação usa `persist()` que chama `apiCall` (online) ou `enqueue` (offline)
- **Não** adicionar novos slices de estado que só vivam em `localStorage` — os dados devem sempre sincronizar com o MySQL

## Localizações no disco

| Projeto      | Caminho        |
|--------------|----------------|
| AT_Manut     | `c:\AT_Manut\` |
| Website Navel| `c:\navel-site\` |

## Boas práticas Git

- **Commits:** Mensagens claras e descritivas (ex.: `v1.4.0 - Corrigir export PDF em relatórios`)
- **Nunca commitar:** passwords, tokens, chaves API, ficheiros `.env` (usar `.env.example` como template)
- **`.gitignore`:** Manter atualizado — `dist/`, `node_modules/`, `dist_upload.zip`, `.env*`, logs
- **Ficheiro grande já commitado:** `git rm --cached ficheiro` + commit + adicionar ao `.gitignore`
- **Autenticação GitHub:** Usar Personal Access Token (não password) — [github.com/settings/tokens](https://github.com/settings/tokens)

## Deployment

**GitHub:** Manter o repo atualizado após cada build fechado — backup em cloud, histórico de versões (tags), base para CI/CD futuro.

```powershell
# Build
npm run build

# Zip para upload cPanel (public_html/manut/)
Compress-Archive -Path "dist\*" -DestinationPath dist_upload.zip -Force

# Push para GitHub (após cada build fechado)
git add -A
git commit -m "v{versão} - resumo"
git tag -a v{versão} -m "Release v{versão}"
git push origin master
git push origin v{versão}

# Ficheiro PHP separado para upload (public_html/api/)
# servidor-cpanel/send-email.php
```

## Incremento de versão

Incrementar `APP_VERSION` em `src/config/version.js` **sempre** que houver um novo deployment.
Formato: `MAJOR.MINOR.PATCH` — patches para correcções, minor para novas funcionalidades.

## Testes E2E (Playwright)

A suite tem **270 testes** (12 specs) em `tests/e2e/` cobrindo todos os fluxos e perfis.

```powershell
# Pré-requisito: servidor de desenvolvimento a correr
npm run dev   # http://localhost:5173

# Suite completa
npx playwright test tests/e2e/

# Spec específico
npx playwright test tests/e2e/12-v170-features.spec.js
```

**Regras:**
- Correr a suite antes de qualquer build importante
- Os testes usam mock de API (`setupApiMock`) — não precisam de servidor real
- Ao alterar seletores CSS usados nos testes, actualizar `tests/e2e/helpers.js` e os specs afectados
- Não usar `button[title*="QR"]` (ambíguo) — usar selector exacto `button[title="Gerar etiqueta QR"]`
- Isolamento de sessão: `await page.evaluate(() => sessionStorage.clear())` antes de `doLoginTecnico()` quando o `beforeEach` faz login como Admin
- Nunca usar `navigate()` directamente no corpo de um componente React — sempre dentro de `useEffect`

## Fluxo pós-testes E2E — Documentação obrigatória

**Após cada ciclo de testes E2E** (novos testes, correcções, novas funcionalidades), executar sempre:

1. Actualizar `APP_VERSION` em `src/config/version.js`
2. Actualizar contagem de testes em: `README.md`, `docs/TESTES-E2E.md`, `docs/ROADMAP.md`, `DOCUMENTACAO.md`, `DESENVOLVIMENTO.md`
3. Documentar bugs corrigidos na secção "Problemas técnicos documentados" de `docs/TESTES-E2E.md`
4. Adicionar entrada ao `CHANGELOG.md` com secções: Correcções, Qualidade (contagem), Documentação actualizada
5. `git add -A` + commit + push

> Ver regra global `post-e2e-docs-workflow.mdc` para o padrão completo reutilizável em todos os projectos.

## Rodapé em relatórios

**Obrigatório:** Todos os relatórios (HTML, PDF, email) devem incluir o rodapé:
`Navel-Açores, Lda — Todos os direitos reservados · v{APP_VERSION}`

- Usar `APP_FOOTER_TEXT` de `src/config/version.js` (inclui versão automaticamente)
- Aplicar em: relatorioHtml.js, gerarPdfRelatorio.js, send-email.php, EnviarDocumentoModal, e qualquer novo relatório
